# p1-lab-12
# Лабораторна робота №12  
## Тема:Колекції. Множина HashSet. Асоціативні масиви Map.
Відповіді на контрольні питання
### 1. Чим інтерфейс Set відрізняється від Collection та List?
Set є підінтерфейсом Collection, але має ключову відмінність - не дозволяє зберігати дублікати елементів. List також є підінтерфейсом Collection, але дозволяє дублікати і зберігає порядок додавання елементів з можливістю доступу за індексом. Set не гарантує порядок і не має індексного доступу.
### 2. Чим HashSet відрізняється від TreeSet?
HashSet використовує хеш-таблицю для зберігання елементів, забезпечує O(1) для основних операцій, але не гарантує порядок. TreeSet використовує червоно-чорне дерево, зберігає елементи у відсортованому порядку, але має складність O(log n) для операцій. TreeSet вимагає, щоб елементи були порівнюваними (Comparable).
### 3. Що таке хешування, хеш, хеш-код, хеш-функція?

Хешування - процес перетворення об'єкта в числове значення
Хеш або хеш-код - числове значення, отримане в результаті хешування
Хеш-функція - алгоритм, який перетворює вхідні дані довільного розміру в число фіксованого розміру

### 4. Яким вимогам має відповідати коректна хеш-функція?

Якщо два об'єкти рівні за equals(), їх хеш-коди повинні бути однаковими
Хеш-код одного об'єкта повинен залишатися незмінним протягом виконання програми
Хеш-функція повинна бути детермінованою (для одного об'єкта завжди повертати однаковий результат)

### 5. Які властивості притаманні хорошій хеш-функції?

Рівномірний розподіл значень (мінімізація колізій)
Швидкість обчислення
Висока чутливість до змін вхідних даних
Використання всіх значущих полів об'єкта

### 6. Якими критеріям мають відповідати об'єкти для HashSet?
Об'єкти повинні коректно реалізовувати методи:

hashCode() - для визначення позиції в хеш-таблиці
equals() - для перевірки рівності об'єктів
Ці методи мають бути узгодженими між собою

### 7. Переваги/недоліки HashSet у порівнянні з TreeSet?
Переваги HashSet:

Швидші операції O(1) проти O(log n)
Не вимагає Comparable
Менше споживання пам'яті

Недоліки HashSet:

Не зберігає порядок
Не можна отримати відсортовані дані
Немає методів для роботи з діапазонами

### 8. Чим size відрізняється від capacity?
Size - фактична кількість елементів в колекції. Capacity - розмір внутрішнього масиву для зберігання. Capacity завжди більший або рівний size. Capacity може бути більшим за size для оптимізації продуктивності та уникнення частих перевиділень пам'яті.
### 9. Що таке load factor і на що він впливає?
Load factor (коефіцієнт завантаження) - порогове значення заповнення хеш-таблиці, після досягнення якого відбувається збільшення capacity (rehashing). Стандартне значення 0.75. Впливає на баланс між використанням пам'яті та швидкістю операцій.
### 10. Що таке асоціативний масив? Чим ключ відрізняється від значення?
Асоціативний масив (Map) - структура даних, що зберігає пари "ключ-значення". Ключ - унікальний ідентифікатор для доступу до даних. Значення - дані, що зберігаються. Ключі унікальні, значення можуть повторюватися.
### 11. Чи може в Map бути кілька однакових ключів або значень?
Кілька однакових ключів - НІ, кожен ключ унікальний. При додаванні дубліката ключа старе значення замінюється новим. Кілька однакових значень - ТАК, різні ключі можуть вказувати на однакові значення.
### 12. Наслідки зберігання неімутабельних об'єктів?
У HashSet: Якщо об'єкт змінюється після додавання, його хеш-код може змінитися, і об'єкт "загубиться" в колекції.
У HashMap як ключ: Зміна ключа після додавання призведе до неможливості знайти значення, оскільки хеш-код змінився.
У HashMap як значення: Проблем немає, значення можуть змінюватися без наслідків.
### 13. Чи можуть об'єкти без Comparable зберігатись у TreeMap?
ТАК, але потрібно передати Comparator при створенні TreeMap. Якщо не передати Comparator і об'єкти не реалізують Comparable, буде викинуто ClassCastException при спробі додавання.
### 14. Чи можуть об'єкти без Comparable зберігатись у HashMap?
ТАК, HashMap не потребує Comparable. Наявність інтерфейсу Comparable не впливає на роботу HashMap, оскільки він використовує тільки hashCode() та equals().
